System-C-1
==========

The repository for the System ANSI C course for http://hackbulgaria.com

Курс по системно програмиране на C към Hack Bulgaria

В курса ще се разгледат основите на езика C и как те се прилагат в истински код от Linux/BSD дистрибуции. Целта на курса е да даде добро начало на всеки който иска да се занимава/забавлява със ситемно прогамиране.

В курса ще се засегнат седните теми:
Vim и Emacs като IDE-та. Религиозни войни. През целия курс ще се представят системни инструменти, които помагат в процеса на разработване - grep, cat, tail,...
Build на проекти, инструменти за dependency reslov, проблеми при build-ване. 
I/O от устройства, конзоли, sockets. Запознаване с прекъсвания от процесора за входно изходни операции.
Debuging with Gdb - как да изпозлване gdb при нас и на отдалечена машина.
Memory management какво става като заделяме и освобождаваме памет. Как ядрото я менажира, как ние трябва да я менажираме. Reference counters и други начини да решим сложни проблеми. Не изпозлване на динамична памет.
Debuging на динамчината памет - Valgrind. Как да правим memory leak-ове и как да ги намираме след това.
Как да debug-ваме с trace-ове и log-ове, защо Gdb не е достатъчно. Изпозлване и четене на syslog, /var/log/messages. Как да накараме процеси и плъгини да ни дават логовете си.
fork и exec, връзки между процеси родители и наследници, кога и защо се изпозлват. Разлизиране на демонизиране и state machines с тях.
Комуникация между процеси.
mutex, locks как да правим комуникацията между процесите да работи правилно винаги(или поне така да изглежда, докато се появи някой странен bug).
Нишки - Posix threads, strings
Избиране на поне 3-4 open source проекти и съствяне на документация за тях.(Примери в часовете ще са Reaver(пример за страхотен чист код), Aircrack-ng(...ще видите кода) и други, все още не са избрани)


Notes : add more C, unit testing за контролните, контрони върху темите 
2 пъти седмично всяко трето занятие е контролно
16 занятия - 16 задачи 


1. Избиране на среда за разработка и припомняне на C - Vim, Emacs, Geany, Eclipse?!?!,….
1.1. Инсталация, plugin-и
1.2. Конфигурация
1.3. Използване на отдалечена машина
1.4. Упражнения с масиви(компилиране на единични файлове, без makefiles)
1.5. Упражнения с писане и четене от файлове

2. Build на проекти и припомняне на C
    2.1. Makefiles - предимстава и недостатъци
2.2. cmake, make, gcc
    2.3. Връзване с библиотеки - динамично и статично
    2.4. Инструменти - ldd, nm,(ще видя още няколко)..
    2.5. Упражнения със структури от данни и няколко библиотеки(pcap, ще помисля за други)
    
3. I/O от устройства
3.1. Как да си намерим устройството - dmesg и /dev
3.2. Как да sniff-нем комункиацията PC - device
3.3. Библиотеки за комуникация с устройства и как да си направим ние примитивна такава
3.4. Упражнения с безжични мишки, USB flash-ки(и още няколко устройства, ще помисля какви да са)

4. Debuging with Gdb
    4.1. Attaching към процес, връзване със source code.
    4.2. Breakpoints, steping through code, layout mode
    4.3. Дебъгване и развитие на кода от предното упражнение


5. Memory management.
5.1. Стек и динамична памет, как се пълнят, подравняват и режат на парчета.
5.2. Добри практики за добра памет.
5.3. Пренаписване на кода от предното упражнение с динамични структури и усложняването

6. Debuging на динамчината памет 
6.1. Valgrind.
(6.2. Още, като се запозная повече с Valgrind ще напълня)
6.3. Поправяне на memory leak-ове от предното упражнение

7. Как да debug-ваме с trace-ове и log-ове. (Още малко четене трябва, за по-подробен план)
7.1. Изпозлване и четене на syslog, /var/log/messages. 
7.2. Как да накараме процеси и плъгини да ни дават логовете си.
7.3. Правене на log на предния код 
7.4. Разглеждане на проблеми при стартиране на непознат софтуер(как да разгледаме кода на flash player и още няколко плейъра или сериозен софтуер)

8. fork и exec
8.1. Връзки между процеси родители и наследници, кога и защо се използват.
8.2. Разлизиране на демонизиране и state machines с тях.
8.3. Упражнение с процес който пуска много собствени копия или програми зададени на терминала като аргумент
8.4. Упражнение как да ограничим и debug-нем такива проблемни процеси

9. Комуникация между процеси.
    9.1. sockets
    9.2. pipes
    9.3. shared memory    
    9.4. Упражнение - създаване на примитивен сървър-клиент
    9.5. Упражнение - създаване на примитивни група процеси използващи обща памет

10. mutex, locks как да правим комуникацията между процесите да работи правилно винаги(или поне така да изглежда, докато се появи някой странен bug).(Още четене)
    10.1. shared memory locking
    10.2. semaphors
    10.3. mutex
    10.4. Упражнение - създаване на примитивни група процеси използващи обща памет по правилния начин

11. Posix threads and fibers as threads
    11.1. Много са лесни.
    11.2. Синхорнизация между тях боли.
    11.3. Упражнение - реализиране на проста state машина с нишки, които се спират и пускат една друга


12. Избиране на поне 3-4 open source проекти и съствяне на документация за тях.(Примери в часовете ще са Reaver(пример за страхотен чист код), Aircrack-ng(...ще видите кода) и други, все още не са избрани)


